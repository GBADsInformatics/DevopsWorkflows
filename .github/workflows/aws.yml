# Defining reusable workflow
name: AWS

# Trigger
on:
  workflow_call:
    inputs:
      SERVICE_NAME:
        required: true
        type: string
      CLUSTER_NAME:
        required: false
        type: string
        default: "GBADs-Dashboards-Cluster"
      AWS_REGION:
        required: false
        type: string
        default: "us-east-2"
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
        

# Workflow to restart AWS services
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Get Commit SHA
        id: commit-hash
        run: echo "::set-output name=sha7::$(echo ${GITHUB_SHA} | cut -c1-7)"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.AWS_REGION }}

      - name: Redeploy Amazon ECS service
        id: deploy-aws
        run: |
          # This script retrieves the existing docker container uri, then combines it with the new commit hash to get the newest container
          # it then creates a task definition and updates the service.
          
          # Retrieving the current task definition
          echo "Retreiving original task definition."
          existing_task_definition_arn=$(aws ecs describe-services --cluster ${{ inputs.CLUSTER_NAME }} --services ${{ inputs.SERVICE_NAME }} --query 'services[0].taskDefinition' --output text)
          existing_task_definition_obj=$(aws ecs describe-task-definition --task-definition $existing_task_definition_arn)
          
          # Retreiving the existing task definition family & ecs container name
          echo "Extracting task definition family name and container name."
          task_family_name=$(echo "$existing_task_definition_obj" | jq -cr '.taskDefinition.family')
          task_revision=$(echo "$existing_task_definition_obj" | jq -cr '.taskDefinition.revision')
          container_name=$(echo "$existing_task_definition_obj" | jq -cr '.taskDefinition.containerDefinitions[0].name')

          # Finding the existing container image. For instance, gbadsinformatics/some-dashboard:xxxxxx
          echo "Extracting the original docker image uri."
          existing_docker_uri=$(echo "$existing_task_definition_obj" | jq -cr '.taskDefinition.containerDefinitions[0].image')
          
          # Take the container image and replacing the tag with the new commit hash
          echo "Calculating the new docker image uri."
          new_docker_uri=$( sed 's/\:[^.]*$//' <<<$existing_docker_uri ):${{ steps.commit-hash.outputs.sha7 }}

          # Get memory and cpu variables
          echo "Extracting original task variables."
          container_memory=$(echo "$existing_task_definition_obj" | jq -cr '.taskDefinition.memory')
          container_cpu=$(echo "$existing_task_definition_obj" | jq -cr '.taskDefinition.cpu')
          container_network_mode=$(echo "$existing_task_definition_obj" | jq -cr '.taskDefinition.networkMode')
          container_exec_role_arn=$(echo "$existing_task_definition_obj" | jq -cr '.taskDefinition.executionRoleArn')

          # Get existing container details but replace the image with the new image
          echo "Extracting original container definition and replacing the docker uri."
          container_definition=$(echo $(echo "$existing_task_definition_obj" | jq -cr '.taskDefinition.containerDefinitions') | jq '.[0] |= . + {image: "'$new_docker_uri'"}')

          # Registering the newest task definition with the new docker container
          echo "Registering the new task definition."
          new_task_definition=$(aws ecs register-task-definition \
            --family "$task_family_name" \
            --container-definitions "$container_definition" \
            --memory "$container_memory" \
            --cpu "$container_cpu" \
            --network-mode "$container_network_mode" \
            --execution-role-arn "$container_exec_role_arn" \
            --requires-compatibilities "FARGATE" \
            --query 'taskDefinition.taskDefinitionArn' --output text)

          # Updating the ecs service to use the new task definition
          echo "Updating the service with the new task definition."
          aws ecs update-service --cluster ${{ inputs.CLUSTER_NAME }} --service ${{ inputs.SERVICE_NAME }} --task-definition ${new_task_definition} --force-new-deployment

          # Retreive log information for later steps          
          echo "Waiting for container to start..."
          sleep 20

          # Set your ECS cluster and service names
          TASK_DEFINITION="${task_family_name}:${task_revision}"

          # 1. Get a list of all tasks (stopped or running) for a given service
          TASKS=$(aws ecs list-tasks --cluster ${{ inputs.CLUSTER_NAME }} --service-name ${{ inputs.SERVICE_NAME }} --query 'taskArns' --output text)

          if [ -z "$TASKS" ]; then
            echo "No tasks found for service ${{ inputs.SERVICE_NAME }}."
            exit 1
          fi

          # 2. Filter out tasks with the given task definition
          FILTERED_TASKS=()
          for TASK in $TASKS; do
            TASK_DEFINITION_ARN=$(aws ecs describe-tasks --cluster ${{ inputs.CLUSTER_NAME }} --tasks $TASK --query 'tasks[0].taskDefinitionArn' --output text)

            if [[ "$TASK_DEFINITION_ARN" == *"$TASK_DEFINITION"* ]]; then
              FILTERED_TASKS+=("$TASK")
            fi
          done

          if [ ${#FILTERED_TASKS[@]} -eq 0 ]; then
            echo "No tasks found for task definition $TASK_DEFINITION in service ${{ inputs.SERVICE_NAME }}."
            exit 1
          fi

          # 3. Sort tasks by time started
          SORTED_TASKS=($(aws ecs describe-tasks --cluster ${{ inputs.CLUSTER_NAME }} --tasks "${FILTERED_TASKS[@]}" --query 'tasks | sort_by(@, &startedAt) | reverse(@) | [].taskArn' --output text))

          # 4. Get the containerID of the newest task
          NEWEST_TASK="${SORTED_TASKS[0]}"
          CONTAINER_ID=$(aws ecs describe-tasks --cluster ${{ inputs.CLUSTER_NAME }} --tasks $NEWEST_TASK --query 'tasks[0].containers[0].runtimeId' --output text)

          log_stream_name="ecs/${container_name}/${CONTAINER_ID}"
          log_group_name=$(echo "$existing_task_definition_obj" | jq -cr '.taskDefinition.containerDefinitions[0].logConfiguration.options."awslogs-group"')

          echo "::set-output name=rollback_task_definition_arn::${existing_task_definition_arn}"
          echo "::set-output name=log_group_name::${log_group_name}"
          echo "::set-output name=log_stream_name::${log_stream_name}"

      - name: Wait for ECS Service to be Healthy
        if: always()
        run: |
          # Wait up to 10 minutes for a successful deployment
          timeout=600
          sleep_duration=10
          end_time=$(date -d "+$timeout seconds" +%s)
          status=""
          while [ $(date +%s) -lt $end_time ]; do
            echo "Waiting for service to be healthy..."
            status=$(aws ecs describe-services --cluster ${{ inputs.CLUSTER_NAME }} --services ${{ inputs.SERVICE_NAME }} --query 'services[0].events[0].message' --output text)
            if [[ "$status" == *"has reached a steady state."* ]]; then
              break
            else
              echo "Waiting for service to be healthy..."
              sleep $sleep_duration
            fi
          done
          if [[ "$status" == *"has reached a steady state."* ]]; then
            echo "Service is healthy."
          else
            echo "Service is unhealthy. Please check the logs below for errors."
            echo "Initiating rollback..."
            aws ecs update-service --cluster ${{ inputs.CLUSTER_NAME }} --service ${{ inputs.SERVICE_NAME }} --task-definition ${{ steps.deploy-aws.outputs.rollback_task_definition_arn }} --force-new-deployment
            echo "Rollback started."
            exit 1
          fi

      - name: Get Container Logs
        if: always()
        run: |
          log_output=$(aws logs get-log-events \
            --log-group-name ${{ steps.deploy-aws.outputs.log_group_name }} \
            --log-stream-name ${{ steps.deploy-aws.outputs.log_stream_name }} \
            --limit 250 2>&1)
          if [[ $log_output == *"An error occurred (ResourceNotFoundException) when calling the GetLogEvents operation"* ]]; then
            echo "No logs found."
          else
            echo "$logs"
          fi
