# Defining reusable workflow
name: AWS

# Trigger
on:
  workflow_call:
    inputs:
      stack-name:
        required: true
        type: string
      template-file:
        required: false
        type: string
        default: '.aws/deployment.yml'
      template-inputs:
        required: false
        type: string
      no-fail-on-empty-changeset:
        required: false
        type: string
        default: "1"
      stack-update-timeout:
        description: In minutes, how long the stack can update before cancelling the update.
        required: false
        type: number
        default: 10
      AWS_REGION:
        required: false
        type: string
        default: "us-east-2"
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      template-input:
        required: false
        

# Workflow to restart AWS services
jobs:
  deploy:
    name: Deploy AWS CloudFormation stack
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        id: configure-credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.AWS_REGION }}

      - name: Deploy AWS CloudFormation template
        id: deploy-cloudformation-template
        uses: aws-actions/aws-cloudformation-github-deploy@master
        with:
          name: ${{ inputs.stack-name }}
          template: ${{ inputs.template-file }}
          no-fail-on-empty-changeset: ${{ inputs.no-fail-on-empty-changeset }}
          parameter-overrides: ${{ secrets.template-input }}

  post-deploy:
    name: Healthcheck & Container Logs
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        id: configure-credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.AWS_REGION }}

      - name: Stack health check
        run:  |
          # Wait 1 minute before starting healthchecks
          sleep 60

          # Wait up to $inputs.stack-update-timeout minutes for a successful deployment
          timeout=${{ inputs.stack-update-timeout}}
          stackname=${{ inputs.stack-name }}
          sleep_duration=25
          end_time=$(date -d "+$timeout minutes" +%s)
          while [ $(date +%s) -lt $end_time ]; do
            echo "Waiting for stack update to be complete..."
            status=$(aws cloudformation describe-stacks --stack-name "$stackname" --query 'Stacks[0].StackStatus' --output text 2>&1)
            if [[ "$status" == 'UPDATE_COMPLETE' || "$status" == 'CREATE_COMPLETE' ]]; then
              break
            else
              sleep $sleep_duration
            fi
          done
          
          status=$(aws cloudformation describe-stacks --stack-name "$stackname" --query 'Stacks[0].StackStatus' --output text 2>&1)
          if [[ "$status" == 'UPDATE_COMPLETE' || "$status" == 'CREATE_COMPLETE' ]]; then
            echo "Stack is healthy with status '$status'"
          elif [[ "$status" == 'UPDATE_IN_PROGRESS' ]]; then
            # Cancel stack update
            aws cloudformation cancel-update-stack --stack-name "$stackname"
            echo "Stack update canceled due to UPDATE_IN_PROGRESS status"
            exit 1
          else
            echo "Stack '$stackname' failed with status '$status'"
            exit 1
          fi

      - name: Container logs
        if: always()
        run:  |
          # Retrieving and printing container logs
          # Fetching group name
          log_group_name=$(aws cloudformation describe-stack-resources \
            --stack-name "${{inputs.stack-name}}" \
            --query 'StackResources[?ResourceType == `AWS::Logs::LogGroup`].PhysicalResourceId' \
            --output text)


          # Get the log stream name from the CloudWatch Logs group
          log_stream_names=$(aws logs describe-log-streams \
            --log-group-name "$log_group_name" \
            --query 'logStreams[*].logStreamName' \
            --order-by LastEventTime \
            --max-items 3 \
            --descending \
            --output json)

          # Get the start time for logs (30 minutes ago) in Unix timestamp format
          start_time=$(date -u -d "-$((${{inputs.stack-update-timeout}} + 1)) minutes" '+%s%3N')

          # Get the end time for logs (now) in Unix timestamp format
          end_time=$(date -u '+%s%3N')

          logs=()
          for log_stream in $(echo "${log_stream_names}" | jq -r '.[]'); do
            logs+=("$(aws logs get-log-events \
              --log-group-name "$log_group_name" \
              --log-stream-name "$log_stream" \
              --start-time $start_time \
              --end-time $end_time \
              --query 'events[*].message' \
              --output json)")
          done

          # Print the container logs in reverse order
            echo "Printing last ${{ inputs.stack-update-timeout }} minutes of logs:"
            for ((i=${#logs[@]}-1; i>=0; i--)); do
              echo -e "\n------------------" 
              echo "Container logs [$(($i + 1))]"
              echo "------------------" 
              # Loop through the JSON array and print each string
              echo "${logs[i]}" | jq -r '.[]' | while IFS= read -r log; do
                echo "$log"
              done
            done

